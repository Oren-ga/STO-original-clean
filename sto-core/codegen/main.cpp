#include <iostream>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <vector>
#include <utility>
#include <string>

#include <map>
#include <set>

#include "driver.hpp"

const std::string TName_str[] = {"int32_t", "int64_t", "var_string", "fix_string"};

std::string cxx_type_name(const FieldType& t) {
    std::stringstream ss;
    ss << TName_str[t.tname];
    assert(t.tname >= BigInt && t.tname <= Char);
    if (t.tname == VarChar || t.tname == Char) {
        ss << '<' << t.len << '>';
    }
    return ss.str();
}

std::string cpp_col_cell_map_init_list(ParsingResult& result) {
    std::stringstream ss;
    auto& fields = result.fields;
    auto& groups = result.groups;

    ss << '{';

    size_t fidx = 0;
    for (auto& f : fields) {
        size_t gidx = 0;
        for (auto& g : groups) {
            if (std::find(g.begin(), g.end(), f.name) != g.end()) {
                // found in group/cell no. gidx
                ss << gidx;
                if ((fidx + 1) < fields.size())
                    ss << ',';
                break;
            }
            ++gidx;
        }
        ++fidx;
    }

    ss << '}';
    return ss.str();
}

void print(ParsingResult &result) {
   using namespace std;

   cout << "Printing result..." << endl;
   cout << "struct name: " << result.struct_name << endl;

   auto &fields = result.fields;
   cout << "Number of fields: " << fields.size() << endl;
   for (size_t i = 0; i < fields.size(); ++i) {
      cout << fields[i].name << " " << cxx_type_name(fields[i].t) << endl;
   }

   auto &groups = result.groups;
   cout << "Number of groups: " << groups.size() << endl;
   for (size_t i = 0; i < groups.size(); ++i) {
      for (size_t j = 0; j < groups[i].size(); j++) {
         cout << groups[i][j] << " ";
      }
      cout << endl;
   }
}

bool type_check(ParsingResult &result) {
    std::set<std::string> field_name_set;
    auto& fields = result.fields;
    for (auto& f : fields) {
        if (field_name_set.find(f.name) != field_name_set.end()) {
            std::cerr << "Error: duplicate field name \"" << f.name << "\"" << std::endl;
            return false;
        }
        field_name_set.insert(f.name);
    }

    assert(field_name_set.size() == fields.size());

    auto& groups = result.groups;
    std::set<std::string> group_fname_set;
    size_t gfields = 0;
    for (auto& g : groups) {
        for (auto& fn : g) {
            if (field_name_set.find(fn) == field_name_set.end()) {
                std::cerr << "Error: field \"" << fn << "\" referenced but undeclared" << std::endl;
                return false;
            }
            if (group_fname_set.find(fn) != group_fname_set.end()) {
                std::cerr << "Error: field \"" << fn << "\" referenced in multiple groups" << std::endl;
                return false;
            }
            group_fname_set.insert(fn);
        }
        gfields += g.size();
    }

    assert(group_fname_set.size() == field_name_set.size());
    assert(group_fname_set.size() == gfields);

    return true;
}

void generate_code(ParsingResult &result) {
    std::stringstream ss;
    std::string struct_name = result.struct_name;

    const std::string idt = "    ";

    auto& fields = result.fields;
    // Print comments
    ss << "// The following code is automatically generated by Hao & Yihe's parser/codegen" << std::endl;
    ss << "// Definitions for row type: " << struct_name << std::endl;
    ss << "// Please do not manually modify!" << std::endl;
    ss << std::endl;

    // Generate struct declaration
    ss << "struct " << struct_name << " {" << std::endl;
    for (auto& f : fields)
        ss << idt << cxx_type_name(f.t) << ' ' << f.name << ';' << std::endl;
    ss << "};" << std::endl;

    ss << std::endl;

    auto& groups = result.groups;

    ss << "namespace ver_sel {" << std::endl << std::endl;

    // Generate VerSel
    ss << "template <typename VersImpl>" << std::endl;
    ss << "class VerSel<" << struct_name << ", VersImpl> : public VerSelBase<VerSel<" << struct_name << ", VersImpl>, VersImpl> {" << std::endl;
    ss << "public:" << std::endl;
    ss << idt << "typedef VersImpl version_type;" << std::endl;
    ss << idt << "static constexpr size_t num_versions = " << groups.size() << ';' << std::endl << std::endl;

    ss << idt << "static int map_impl(int col_n) {" << std::endl;
    ss << idt << idt << "return col_cell_map[col_n];" << std::endl;
    ss << idt << '}' << std::endl << std::endl;

    ss << idt << "version_type& version_at_impl(int cell) {" << std::endl;
    ss << idt << idt << "return vers_[cell];" << std::endl;
    ss << idt << '}' << std::endl << std::endl;

    ss << idt << "void install_by_cell_impl(" << struct_name << " *dst, const " << struct_name << " *src, int cell) {" << std::endl;
    ss << idt << idt << "switch (cell) {" << std::endl;

    size_t idx = 0;
    for (auto& g : groups) {
        ss << idt << idt << "case " << idx << ':' << std::endl;
        for (auto& fn : g)
            ss << idt << idt << idt << "dst->" << fn << " = " << "src->" << fn << ';' << std::endl;
        ss << idt << idt << idt << "break;" << std::endl;
        ++idx;
    }

    ss << idt << idt << "default:" << std::endl;
    ss << idt << idt << idt << "assert(false, \"cell id out of bound\\n\");" << std::endl;
    ss << idt << idt << idt << "break;" << std::endl;
    ss << idt << idt << '}' << std::endl;
    ss << idt << '}' << std::endl << std::endl;

    ss << "private:" << std::endl;
    ss << idt << "version_type vers_[num_versions];" << std::endl;
    ss << idt << "static constexpr int col_cell_map[] = " << cpp_col_cell_map_init_list(result) << ';' << std::endl;

    ss << "};" << std::endl << std::endl;

    ss << "}; // namespace ver_sel";

    std::cout << ss.str() << std::endl;
}

int main(const int argc, const char **argv) {
    /** check for the right # of arguments **/
    ParsingResult result;
    if( argc == 2 ) {
        MC::MC_Driver driver;
        /** example for piping input from terminal, i.e., using cat **/
        if( std::strncmp( argv[ 1 ], "-o", 2 ) == 0 ) {
            driver.parse( std::cin, result );
        }
        /** simple help menu **/
        else if( std::strncmp( argv[ 1 ], "-h", 2 ) == 0 ) {
            std::cout << "use -o for pipe to std::cin\n";
            std::cout << "just give a filename to count from a file\n";
            std::cout << "use -h to get this menu\n";
            return( EXIT_SUCCESS );
        }
        /** example reading input from a file **/
        else {
            /** assume file, prod code, use stat to check **/
            driver.parse( argv[1], result );
        }
    } else {
        /** exit with failure condition **/
        return ( EXIT_FAILURE );
    }

    print(result);

    if (!type_check(result)) {
        std::cout << "Type checker error" << std::endl;
        return ( EXIT_FAILURE );
    }

    generate_code(result);

    return( EXIT_SUCCESS );
}
