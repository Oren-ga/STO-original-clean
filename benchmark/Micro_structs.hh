#pragma once
// The following code is automatically generated by Hao & Yihe's parser/codegen
// Please do not manually modify!

// Definitions for row type: one_version_row
struct one_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};


// Definitions for row type: two_version_row
struct two_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};


// Definitions for row type: four_version_row
struct four_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};


// Definitions for row type: eight_version_row
struct eight_version_row {

    enum class NamedColumn : int { f1 = 0, f2, f3, f4, f5, f6, f7, f8 };

    int64_t f1;
    int64_t f2;
    int64_t f3;
    int64_t f4;
    int64_t f5;
    int64_t f6;
    int64_t f7;
    int64_t f8;
};

namespace ver_sel {

template <typename VersImpl>
class VerSel<one_version_row, VersImpl> : public VerSelBase<VerSel<one_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 1;

    explicit VerSel(type v) {
        (void)v;
    }
    VerSel(type v, bool insert) {
        (void)v; (void)insert;
    }

    static int map_impl(int col_n) {
        return col_cell_map[col_n];
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(one_version_row *dst, const one_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            dst->f2 = src->f2;
            dst->f3 = src->f3;
            dst->f4 = src->f4;
            dst->f5 = src->f5;
            dst->f6 = src->f6;
            dst->f7 = src->f7;
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr int col_cell_map[] = {0,0,0,0,0,0,0,0};
};


template <typename VersImpl>
class VerSel<two_version_row, VersImpl> : public VerSelBase<VerSel<two_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 2;

    explicit VerSel(type v) {
        (void)v;
    }
    VerSel(type v, bool insert) {
        (void)v; (void)insert;
    }

    static int map_impl(int col_n) {
        return col_cell_map[col_n];
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(two_version_row *dst, const two_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            dst->f2 = src->f2;
            dst->f3 = src->f3;
            dst->f4 = src->f4;
            break;
        case 1:
            dst->f5 = src->f5;
            dst->f6 = src->f6;
            dst->f7 = src->f7;
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr int col_cell_map[] = {0,0,0,0,1,1,1,1};
};


template <typename VersImpl>
class VerSel<four_version_row, VersImpl> : public VerSelBase<VerSel<four_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 4;

    explicit VerSel(type v) {
        (void)v;
    }
    VerSel(type v, bool insert) {
        (void)v; (void)insert;
    }

    static int map_impl(int col_n) {
        return col_cell_map[col_n];
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(four_version_row *dst, const four_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            dst->f2 = src->f2;
            break;
        case 1:
            dst->f3 = src->f3;
            dst->f4 = src->f4;
            break;
        case 2:
            dst->f5 = src->f5;
            dst->f6 = src->f6;
            break;
        case 3:
            dst->f7 = src->f7;
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr int col_cell_map[] = {0,0,1,1,2,2,3,3};
};


template <typename VersImpl>
class VerSel<eight_version_row, VersImpl> : public VerSelBase<VerSel<eight_version_row, VersImpl>, VersImpl> {
public:
    typedef VersImpl version_type;
    static constexpr size_t num_versions = 8;

    explicit VerSel(type v) {
        (void)v;
    }
    VerSel(type v, bool insert) {
        (void)v; (void)insert;
    }

    static int map_impl(int col_n) {
        return col_cell_map[col_n];
    }

    version_type& version_at_impl(int cell) {
        return vers_[cell];
    }

    void install_by_cell_impl(eight_version_row *dst, const eight_version_row *src, int cell) {
        switch (cell) {
        case 0:
            dst->f1 = src->f1;
            break;
        case 1:
            dst->f2 = src->f2;
            break;
        case 2:
            dst->f3 = src->f3;
            break;
        case 3:
            dst->f4 = src->f4;
            break;
        case 4:
            dst->f5 = src->f5;
            break;
        case 5:
            dst->f6 = src->f6;
            break;
        case 6:
            dst->f7 = src->f7;
            break;
        case 7:
            dst->f8 = src->f8;
            break;
        default:
            always_assert(false, "cell id out of bound\n");
            break;
        }
    }

private:
    version_type vers_[num_versions];
    static constexpr int col_cell_map[] = {0,1,2,3,4,5,6,7};
};


}; // namespace ver_sel
